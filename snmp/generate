#!/usr/bin/env python3

import csv
import re
import os
import sys
from collections import defaultdict

def generateName(val):
    return re.sub(r'^(unifi|ubnt|Ubnt)', "", val)

output = open(sys.argv[2],"w")
structs = defaultdict(lambda: list())
structNames = {}
types = {
    "DISPLAYSTRING": "string",
    "IPADDRESS":     "net.IP",
    "OCTET STRING":  "[]byte",
    "INTEGER":       "int",
    "INTEGER32":     "int32",
    "COUNTER32":     "uint32",
}
output.write('package snmp\n\n')
output.write('import "net"\n\n')


with open(sys.argv[1]) as f:
    reader = csv.DictReader(f)

    for row in reader:
        (_, parent, name) = row["Full Name"].rsplit(".",2)

        structNames[row["Name"]] = row["Type"] or row["Name"]

        match = re.search('^SEQUENCE OF (.+)', row['Type'])
        if match:
            row["Type"] = "[]" + generateName(match.group(1))
            structs[parent].append(row)
        elif row['Access'] != "not-accessible":
            structs[parent].append(row)

for k, fields in structs.items():
    names = list(map(lambda x: x['Name'], fields))

    if len(names) > 1:
        prefix = os.path.commonprefix(list(names))
    else:
        prefix = ""

    k = generateName(structNames.get(k,k))
    output.write("type "+k+" struct {\n")
#
    for row in fields:
        name = row['Name'][len(prefix):]
        name = generateName(name)
        name = re.sub(r'I[dp]$', lambda match: match.group(0).upper(), name)
        
        type = row["Type"] or row["Name"]
        type = generateName(types.get(type.upper(), "*"+type))

        output.write("\t{name}\t{type}\t`oid:\"{oid}\"`\n".format(name=name, oid=row["OID"], type=type))

    output.write("}\n")
